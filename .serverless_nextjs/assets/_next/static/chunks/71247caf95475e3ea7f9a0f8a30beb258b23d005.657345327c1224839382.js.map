{"version":3,"sources":["webpack://_N_E/../../../next-server/lib/amp.ts","webpack://_N_E/../../../next-server/lib/head.tsx","webpack://_N_E/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://_N_E/./node_modules/mobx-react/dist/mobxreact.esm.js","webpack://_N_E/../../../next-server/lib/side-effect.tsx","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/assertEnvironment.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/observerBatching.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/utils.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/printDebugValue.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js","webpack://_N_E/./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js","webpack://_N_E/./node_modules/mobx-react-lite/es/staticRendering.js","webpack://_N_E/./node_modules/mobx-react-lite/es/useObserver.js","webpack://_N_E/./node_modules/mobx-react-lite/es/observer.js","webpack://_N_E/./node_modules/mobx-react-lite/es/ObserverComponent.js","webpack://_N_E/./node_modules/mobx-react-lite/es/useAsObservableSource.js","webpack://_N_E/./node_modules/mobx-react-lite/es/index.js","webpack://_N_E/./node_modules/next/head.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://_N_E/../../../next-server/lib/amp-context.ts","webpack://_N_E/(webpack)/webpack/global.js"],"names":["isInAmpMode","React","AmpStateContext","ampFirst","hybrid","hasQuery","defaultHead","inAmpMode","head","charSet","name","content","onlyReactElement","child","list","fragmentChild","fragmentList","METATYPES","reduceComponents","headElements","headElementChildren","headElement","props","keys","tags","metaTypes","metaCategories","h","isUnique","hasKey","key","i","len","metatype","category","categories","unique","c","Head","ampState","useContext","headManager","HeadManagerContext","reduceComponentsToState","module","exports","TypeError","iter","Symbol","iterator","Object","Array","from","arrayLikeToArray","arr","isArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","symbolId","createdSymbols","newSymbol","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","keysB","length","hasOwnProperty","call","x","y","hoistBlackList","$$typeof","render","compare","type","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","setHiddenProp","target","prop","value","defineProperty","enumerable","configurable","writable","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","_this","this","_len","arguments","args","_key","locks","retVal","undefined","apply","methods","forEach","mx","wrapFunction","_len2","_key2","concat","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","getOwnPropertyDescriptor","originalMethod","newDefinition","createDefinition","_ref","wrappedFunc","get","set","mobxAdminProperty","mobxObserverProperty","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","makeClassComponentObserver","componentClass","prototype","displayName","getDisplayName","console","warn","componentWillReact","Error","shouldComponentUpdate","observerSCU","makeObservableProp","baseRender","makeComponentReactive","_this$render$mobxAdmi","dispose","_displayName","comp","constructor","initialName","bind","isRenderingPending","reaction","hasError","forceUpdate","reactiveRender","exception","rendering","track","e","nextProps","nextState","state","propName","valueHolderKey","atomHolderKey","getAtom","prevReadState","reportObserved","v","reportChanged","hasSymbol","ReactForwardRefSymbol","ReactMemoSymbol","_extends","assign","source","MobXProviderContext","createContext","Provider","children","stores","excluded","sourceKeys","_objectWithoutPropertiesLoose","parentValue","useRef","current","createElement","createStoreInjector","grabStoresFn","component","injectNames","makeReactive","Injector","forwardRef","ref","newProps","context","isPrototypeOf","observer","base","protoProps","getOwnPropertyNames","getPrototypeOf","copyStaticProperties","componentName","getInjectName","grabStoresByName","storeNames","baseStores","storeName","inject","join","_hasHeadManager","emitChange","Component","defaultNoopBatch","callback","__read","o","n","m","r","ar","next","done","error","EMPTY_ARRAY","printDebugValue","FinalizationRegistryLocal","FinalizationRegistry","createTrackingData","mounted","changedBeforeMount","cleanAt","Date","now","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","__values","s","cleanupTokenToReactionTrackingMap","Map","globalCleanupTokensCounter","registry","token","trackedReaction","delete","addReactionToTrack","reactionTrackingRef","objectRetainedByReact","register","finalizationRegistryCleanupToken","recordReactionAsCommitted","reactionRef","unregister","forceCleanupTimerToRunNowForTests","resetCleanupScheduleForTests","createReactionCleanupTrackingUsingFinalizationRegister","reactionCleanupHandle","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","setTimeout","cleanUncommittedReactions","tracking","size","add","clearTimeout","e_1","_a","uncommittedReactionRefs_1","uncommittedReactionRefs_1_1","e_1_1","return","clear","createTimerBasedReactionCleanupTracking","globalIsUsingStaticRendering","enableStaticRendering","enable","isUsingStaticRendering","observerComponentNameFor","baseComponentName","ObjectToBeRetainedByReact","useObserver","fn","useState","setTick","tick","useForceUpdate","newReaction","trackingData_1","useDebugValue","useEffect","Infinity","__assign","t","p","baseComponent","options","memoComponent","realOptions","wrappedComponent","ObserverComponent","reactionScheduler","obj","__webpack_modules__","149","g","Function","window","__webpack_module_cache__","__nccwpck_require__","moduleId","threw","ab","__dirname"],"mappings":"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","file":"static/chunks/71247caf95475e3ea7f9a0f8a30beb258b23d005.657345327c1224839382.js","sourcesContent":["import React from 'react'\nimport { AmpStateContext } from './amp-context'\n\nexport function isInAmpMode({\n  ampFirst = false,\n  hybrid = false,\n  hasQuery = false,\n} = {}): boolean {\n  return ampFirst || (hybrid && hasQuery)\n}\n\nexport function useAmp(): boolean {\n  // Don't assign the context value to a variable to save bytes\n  return isInAmpMode(React.useContext(AmpStateContext))\n}\n","import React, { useContext } from 'react'\nimport Effect from './side-effect'\nimport { AmpStateContext } from './amp-context'\nimport { HeadManagerContext } from './head-manager-context'\nimport { isInAmpMode } from './amp'\n\ntype WithInAmpMode = {\n  inAmpMode?: boolean\n}\n\nexport function defaultHead(inAmpMode = false): JSX.Element[] {\n  const head = [<meta charSet=\"utf-8\" />]\n  if (!inAmpMode) {\n    head.push(<meta name=\"viewport\" content=\"width=device-width\" />)\n  }\n  return head\n}\n\nfunction onlyReactElement(\n  list: Array<React.ReactElement<any>>,\n  child: React.ReactChild\n): Array<React.ReactElement<any>> {\n  // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n  if (typeof child === 'string' || typeof child === 'number') {\n    return list\n  }\n  // Adds support for React.Fragment\n  if (child.type === React.Fragment) {\n    return list.concat(\n      React.Children.toArray(child.props.children).reduce(\n        (\n          fragmentList: Array<React.ReactElement<any>>,\n          fragmentChild: React.ReactChild\n        ): Array<React.ReactElement<any>> => {\n          if (\n            typeof fragmentChild === 'string' ||\n            typeof fragmentChild === 'number'\n          ) {\n            return fragmentList\n          }\n          return fragmentList.concat(fragmentChild)\n        },\n        []\n      )\n    )\n  }\n  return list.concat(child)\n}\n\nconst METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp']\n\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/\nfunction unique() {\n  const keys = new Set()\n  const tags = new Set()\n  const metaTypes = new Set()\n  const metaCategories: { [metatype: string]: Set<string> } = {}\n\n  return (h: React.ReactElement<any>) => {\n    let isUnique = true\n    let hasKey = false\n\n    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n      hasKey = true\n      const key = h.key.slice(h.key.indexOf('$') + 1)\n      if (keys.has(key)) {\n        isUnique = false\n      } else {\n        keys.add(key)\n      }\n    }\n\n    // eslint-disable-next-line default-case\n    switch (h.type) {\n      case 'title':\n      case 'base':\n        if (tags.has(h.type)) {\n          isUnique = false\n        } else {\n          tags.add(h.type)\n        }\n        break\n      case 'meta':\n        for (let i = 0, len = METATYPES.length; i < len; i++) {\n          const metatype = METATYPES[i]\n          if (!h.props.hasOwnProperty(metatype)) continue\n\n          if (metatype === 'charSet') {\n            if (metaTypes.has(metatype)) {\n              isUnique = false\n            } else {\n              metaTypes.add(metatype)\n            }\n          } else {\n            const category = h.props[metatype]\n            const categories = metaCategories[metatype] || new Set()\n            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n              isUnique = false\n            } else {\n              categories.add(category)\n              metaCategories[metatype] = categories\n            }\n          }\n        }\n        break\n    }\n\n    return isUnique\n  }\n}\n\n/**\n *\n * @param headElements List of multiple <Head> instances\n */\nfunction reduceComponents(\n  headElements: Array<React.ReactElement<any>>,\n  props: WithInAmpMode\n) {\n  return headElements\n    .reduce(\n      (list: React.ReactChild[], headElement: React.ReactElement<any>) => {\n        const headElementChildren = React.Children.toArray(\n          headElement.props.children\n        )\n        return list.concat(headElementChildren)\n      },\n      []\n    )\n    .reduce(onlyReactElement, [])\n    .reverse()\n    .concat(defaultHead(props.inAmpMode))\n    .filter(unique())\n    .reverse()\n    .map((c: React.ReactElement<any>, i: number) => {\n      const key = c.key || i\n      if (\n        process.env.NODE_ENV !== 'development' &&\n        process.env.__NEXT_OPTIMIZE_FONTS &&\n        !props.inAmpMode\n      ) {\n        if (\n          c.type === 'link' &&\n          c.props['href'] &&\n          // TODO(prateekbh@): Replace this with const from `constants` when the tree shaking works.\n          ['https://fonts.googleapis.com/css'].some((url) =>\n            c.props['href'].startsWith(url)\n          )\n        ) {\n          const newProps = { ...(c.props || {}) }\n          newProps['data-href'] = newProps['href']\n          newProps['href'] = undefined\n          return React.cloneElement(c, newProps)\n        }\n      }\n      return React.cloneElement(c, { key })\n    })\n}\n\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */\nfunction Head({ children }: { children: React.ReactNode }) {\n  const ampState = useContext(AmpStateContext)\n  const headManager = useContext(HeadManagerContext)\n  return (\n    <Effect\n      reduceComponentsToState={reduceComponents}\n      headManager={headManager}\n      inAmpMode={isInAmpMode(ampState)}\n    >\n      {children}\n    </Effect>\n  )\n}\n\n// TODO: Remove in the next major release\nHead.rewind = () => {}\n\nexport default Head\n","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","import { Reaction, _allowStateChanges, _allowStateReadsStart, _allowStateReadsEnd, $mobx, createAtom, untracked, isObservableMap, isObservableObject, isObservableArray, observable } from 'mobx';\nimport React__default, { PureComponent, Component, forwardRef, memo, createElement } from 'react';\nimport { isUsingStaticRendering, Observer, observer as observer$1 } from 'mobx-react-lite';\nexport { Observer, enableStaticRendering, isUsingStaticRendering, observerBatching, useAsObservableSource, useLocalObservable, useLocalStore, useObserver, useStaticRendering } from 'mobx-react-lite';\n\nvar symbolId = 0;\n\nfunction createSymbol(name) {\n  if (typeof Symbol === \"function\") {\n    return Symbol(name);\n  }\n\n  var symbol = \"__$mobx-react \" + name + \" (\" + symbolId + \")\";\n  symbolId++;\n  return symbol;\n}\n\nvar createdSymbols = {};\nfunction newSymbol(name) {\n  if (!createdSymbols[name]) {\n    createdSymbols[name] = createSymbol(name);\n  }\n\n  return createdSymbols[name];\n}\nfunction shallowEqual(objA, objB) {\n  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\n\n\nvar hoistBlackList = {\n  $$typeof: 1,\n  render: 1,\n  compare: 1,\n  type: 1,\n  childContextTypes: 1,\n  contextType: 1,\n  contextTypes: 1,\n  defaultProps: 1,\n  getDefaultProps: 1,\n  getDerivedStateFromError: 1,\n  getDerivedStateFromProps: 1,\n  mixins: 1,\n  propTypes: 1\n};\nfunction copyStaticProperties(base, target) {\n  var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n  Object.getOwnPropertyNames(base).forEach(function (key) {\n    if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n/**\r\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\r\n * @param target\r\n * @param prop\r\n * @param value\r\n */\n\nfunction setHiddenProp(target, prop, value) {\n  if (!Object.hasOwnProperty.call(target, prop)) {\n    Object.defineProperty(target, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    target[prop] = value;\n  }\n}\n/**\r\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\r\n * and the handler provided by mobx-react\r\n */\n\nvar mobxMixins = /*#__PURE__*/newSymbol(\"patchMixins\");\nvar mobxPatchedDefinition = /*#__PURE__*/newSymbol(\"patchedDefinition\");\n\nfunction getMixins(target, methodName) {\n  var mixins = target[mobxMixins] = target[mobxMixins] || {};\n  var methodMixins = mixins[methodName] = mixins[methodName] || {};\n  methodMixins.locks = methodMixins.locks || 0;\n  methodMixins.methods = methodMixins.methods || [];\n  return methodMixins;\n}\n\nfunction wrapper(realMethod, mixins) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n  mixins.locks++;\n\n  try {\n    var retVal;\n\n    if (realMethod !== undefined && realMethod !== null) {\n      retVal = realMethod.apply(this, args);\n    }\n\n    return retVal;\n  } finally {\n    mixins.locks--;\n\n    if (mixins.locks === 0) {\n      mixins.methods.forEach(function (mx) {\n        mx.apply(_this, args);\n      });\n    }\n  }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n  var fn = function fn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));\n  };\n\n  return fn;\n}\n\nfunction patch(target, methodName, mixinMethod) {\n  var mixins = getMixins(target, methodName);\n\n  if (mixins.methods.indexOf(mixinMethod) < 0) {\n    mixins.methods.push(mixinMethod);\n  }\n\n  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n\n  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n    // already patched definition, do not repatch\n    return;\n  }\n\n  var originalMethod = target[methodName];\n  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n  Object.defineProperty(target, methodName, newDefinition);\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n  var _ref;\n\n  var wrappedFunc = wrapFunction(originalMethod, mixins);\n  return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get() {\n    return wrappedFunc;\n  }, _ref.set = function set(value) {\n    if (this === target) {\n      wrappedFunc = wrapFunction(value, mixins);\n    } else {\n      // when it is an instance of the prototype/a child prototype patch that particular case again separately\n      // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n      // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n      // as the method for the instance\n      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n      Object.defineProperty(this, methodName, newDefinition);\n    }\n  }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;\n}\n\nvar mobxAdminProperty = $mobx || \"$mobx\";\nvar mobxObserverProperty = /*#__PURE__*/newSymbol(\"isMobXReactObserver\");\nvar mobxIsUnmounted = /*#__PURE__*/newSymbol(\"isUnmounted\");\nvar skipRenderKey = /*#__PURE__*/newSymbol(\"skipRender\");\nvar isForcingUpdateKey = /*#__PURE__*/newSymbol(\"isForcingUpdate\");\nfunction makeClassComponentObserver(componentClass) {\n  var target = componentClass.prototype;\n\n  if (componentClass[mobxObserverProperty]) {\n    var displayName = getDisplayName(target);\n    console.warn(\"The provided component class (\" + displayName + \") \\n                has already been declared as an observer component.\");\n  } else {\n    componentClass[mobxObserverProperty] = true;\n  }\n\n  if (target.componentWillReact) throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n\n  if (componentClass[\"__proto__\"] !== PureComponent) {\n    if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU;else if (target.shouldComponentUpdate !== observerSCU) // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n      throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n  } // this.props and this.state are made observable, just to make sure @computed fields that\n  // are defined inside the component, and which rely on state or props, re-compute if state or props change\n  // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n  // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n\n\n  makeObservableProp(target, \"props\");\n  makeObservableProp(target, \"state\");\n  var baseRender = target.render;\n\n  target.render = function () {\n    return makeComponentReactive.call(this, baseRender);\n  };\n\n  patch(target, \"componentWillUnmount\", function () {\n    var _this$render$mobxAdmi;\n\n    if (isUsingStaticRendering() === true) return;\n    (_this$render$mobxAdmi = this.render[mobxAdminProperty]) == null ? void 0 : _this$render$mobxAdmi.dispose();\n    this[mobxIsUnmounted] = true;\n\n    if (!this.render[mobxAdminProperty]) {\n      // Render may have been hot-swapped and/or overriden by a subclass.\n      var _displayName = getDisplayName(this);\n\n      console.warn(\"The reactive render of an observer class component (\" + _displayName + \") \\n                was overriden after MobX attached. This may result in a memory leak if the \\n                overriden reactive render was not properly disposed.\");\n    }\n  });\n  return componentClass;\n} // Generates a friendly name for debugging\n\nfunction getDisplayName(comp) {\n  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || \"<component>\";\n}\n\nfunction makeComponentReactive(render) {\n  var _this = this;\n\n  if (isUsingStaticRendering() === true) return render.call(this);\n  /**\r\n   * If props are shallowly modified, react will render anyway,\r\n   * so atom.reportChanged() should not result in yet another re-render\r\n   */\n\n  setHiddenProp(this, skipRenderKey, false);\n  /**\r\n   * forceUpdate will re-assign this.props. We don't want that to cause a loop,\r\n   * so detect these changes\r\n   */\n\n  setHiddenProp(this, isForcingUpdateKey, false);\n  var initialName = getDisplayName(this);\n  var baseRender = render.bind(this);\n  var isRenderingPending = false;\n  var reaction = new Reaction(initialName + \".render()\", function () {\n    if (!isRenderingPending) {\n      // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n      // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n      // See #85 / Pull #44\n      isRenderingPending = true;\n\n      if (_this[mobxIsUnmounted] !== true) {\n        var hasError = true;\n\n        try {\n          setHiddenProp(_this, isForcingUpdateKey, true);\n          if (!_this[skipRenderKey]) Component.prototype.forceUpdate.call(_this);\n          hasError = false;\n        } finally {\n          setHiddenProp(_this, isForcingUpdateKey, false);\n          if (hasError) reaction.dispose();\n        }\n      }\n    }\n  });\n  reaction[\"reactComponent\"] = this;\n  reactiveRender[mobxAdminProperty] = reaction;\n  this.render = reactiveRender;\n\n  function reactiveRender() {\n    isRenderingPending = false;\n    var exception = undefined;\n    var rendering = undefined;\n    reaction.track(function () {\n      try {\n        rendering = _allowStateChanges(false, baseRender);\n      } catch (e) {\n        exception = e;\n      }\n    });\n\n    if (exception) {\n      throw exception;\n    }\n\n    return rendering;\n  }\n\n  return reactiveRender.call(this);\n}\n\nfunction observerSCU(nextProps, nextState) {\n  if (isUsingStaticRendering()) {\n    console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n  } // update on any state changes (as is the default)\n\n\n  if (this.state !== nextState) {\n    return true;\n  } // update if props are shallowly not equal, inspired by PureRenderMixin\n  // we could return just 'false' here, and avoid the `skipRender` checks etc\n  // however, it is nicer if lifecycle events are triggered like usually,\n  // so we return true here if props are shallowly modified.\n\n\n  return !shallowEqual(this.props, nextProps);\n}\n\nfunction makeObservableProp(target, propName) {\n  var valueHolderKey = newSymbol(\"reactProp_\" + propName + \"_valueHolder\");\n  var atomHolderKey = newSymbol(\"reactProp_\" + propName + \"_atomHolder\");\n\n  function getAtom() {\n    if (!this[atomHolderKey]) {\n      setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName));\n    }\n\n    return this[atomHolderKey];\n  }\n\n  Object.defineProperty(target, propName, {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      var prevReadState = false;\n\n      if (_allowStateReadsStart && _allowStateReadsEnd) {\n        prevReadState = _allowStateReadsStart(true);\n      }\n\n      getAtom.call(this).reportObserved();\n\n      if (_allowStateReadsStart && _allowStateReadsEnd) {\n        _allowStateReadsEnd(prevReadState);\n      }\n\n      return this[valueHolderKey];\n    },\n    set: function set(v) {\n      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n        setHiddenProp(this, valueHolderKey, v);\n        setHiddenProp(this, skipRenderKey, true);\n        getAtom.call(this).reportChanged();\n        setHiddenProp(this, skipRenderKey, false);\n      } else {\n        setHiddenProp(this, valueHolderKey, v);\n      }\n    }\n  });\n}\n\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"]; // Using react-is had some issues (and operates on elements, not on types), see #608 / #609\n\nvar ReactForwardRefSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.forward_ref\") : typeof forwardRef === \"function\" && /*#__PURE__*/forwardRef(function (props) {\n  return null;\n})[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.memo\") : typeof memo === \"function\" && /*#__PURE__*/memo(function (props) {\n  return null;\n})[\"$$typeof\"];\n/**\r\n * Observer function / decorator\r\n */\n\nfunction observer(component) {\n  if (component[\"isMobxInjector\"] === true) {\n    console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n  }\n\n  if (ReactMemoSymbol && component[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\");\n  } // Unwrap forward refs into `<Observer>` component\n  // we need to unwrap the render, because it is the inner render that needs to be tracked,\n  // not the ForwardRef HoC\n\n\n  if (ReactForwardRefSymbol && component[\"$$typeof\"] === ReactForwardRefSymbol) {\n    var baseRender = component[\"render\"];\n    if (typeof baseRender !== \"function\") throw new Error(\"render property of ForwardRef was not a function\");\n    return forwardRef(function ObserverForwardRef() {\n      var args = arguments;\n      return createElement(Observer, null, function () {\n        return baseRender.apply(undefined, args);\n      });\n    });\n  } // Function component\n\n\n  if (typeof component === \"function\" && (!component.prototype || !component.prototype.render) && !component[\"isReactClass\"] && !Object.prototype.isPrototypeOf.call(Component, component)) {\n    return observer$1(component);\n  }\n\n  return makeClassComponentObserver(component);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar MobXProviderContext = /*#__PURE__*/React__default.createContext({});\nfunction Provider(props) {\n  var children = props.children,\n      stores = _objectWithoutPropertiesLoose(props, [\"children\"]);\n\n  var parentValue = React__default.useContext(MobXProviderContext);\n  var mutableProviderRef = React__default.useRef(_extends({}, parentValue, stores));\n  var value = mutableProviderRef.current;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var newValue = _extends({}, value, stores); // spread in previous state for the context based stores\n\n\n    if (!shallowEqual(value, newValue)) {\n      throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n    }\n  }\n\n  return React__default.createElement(MobXProviderContext.Provider, {\n    value: value\n  }, children);\n}\nProvider.displayName = \"MobXProvider\";\n\n/**\r\n * Store Injection\r\n */\n\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n  // Support forward refs\n  var Injector = React__default.forwardRef(function (props, ref) {\n    var newProps = _extends({}, props);\n\n    var context = React__default.useContext(MobXProviderContext);\n    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n\n    if (ref) {\n      newProps.ref = ref;\n    }\n\n    return React__default.createElement(component, newProps);\n  });\n  if (makeReactive) Injector = observer(Injector);\n  Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n  // Static fields from component should be visible on the generated Injector\n\n  copyStaticProperties(component, Injector);\n  Injector[\"wrappedComponent\"] = component;\n  Injector.displayName = getInjectName(component, injectNames);\n  return Injector;\n}\n\nfunction getInjectName(component, injectNames) {\n  var displayName;\n  var componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n  if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";else displayName = \"inject(\" + componentName + \")\";\n  return displayName;\n}\n\nfunction grabStoresByName(storeNames) {\n  return function (baseStores, nextProps) {\n    storeNames.forEach(function (storeName) {\n      if (storeName in nextProps // prefer props over stores\n      ) return;\n      if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n      nextProps[storeName] = baseStores[storeName];\n    });\n    return nextProps;\n  };\n}\n/**\r\n * higher order component that injects stores to a child.\r\n * takes either a varargs list of strings, which are stores read from the context,\r\n * or a function that manually maps the available stores from the context to props:\r\n * storesToProps(mobxStores, props, context) => newProps\r\n */\n\n\nfunction inject() {\n  for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    storeNames[_key] = arguments[_key];\n  }\n\n  if (typeof arguments[0] === \"function\") {\n    var grabStoresFn = arguments[0];\n    return function (componentClass) {\n      return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n    };\n  } else {\n    return function (componentClass) {\n      return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n    };\n  }\n}\n\nvar protoStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountProto\");\nvar instStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountInst\");\n\nfunction runDisposersOnWillUnmount() {\n  var _this = this;\n  [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function (propKeyOrFunction) {\n    var prop = typeof propKeyOrFunction === \"string\" ? _this[propKeyOrFunction] : propKeyOrFunction;\n\n    if (prop !== undefined && prop !== null) {\n      if (Array.isArray(prop)) prop.map(function (f) {\n        return f();\n      });else prop();\n    }\n  });\n}\n\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n  if (Array.isArray(propertyKeyOrFunction)) {\n    return propertyKeyOrFunction.map(function (fn) {\n      return disposeOnUnmount(target, fn);\n    });\n  }\n\n  var c = Object.getPrototypeOf(target).constructor;\n  var c2 = Object.getPrototypeOf(target.constructor); // Special case for react-hot-loader\n\n  var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));\n\n  if (!(c === React__default.Component || c === React__default.PureComponent || c2 === React__default.Component || c2 === React__default.PureComponent || c3 === React__default.Component || c3 === React__default.PureComponent)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n  }\n\n  if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n  } // decorator's target is the prototype, so it doesn't have any instance properties like props\n\n\n  var isDecorator = typeof propertyKeyOrFunction === \"string\"; // add property key / function we want run (disposed) to the store\n\n  var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n  var store = isDecorator ? // decorators are added to the prototype store\n  target[protoStoreKey] || (target[protoStoreKey] = []) : // functions are added to the instance store\n  target[instStoreKey] || (target[instStoreKey] = []);\n  store.push(propertyKeyOrFunction); // tweak the component class componentWillUnmount if not done already\n\n  if (!componentWasAlreadyModified) {\n    patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n  } // return the disposer as is if invoked as a non decorator\n\n\n  if (typeof propertyKeyOrFunction !== \"string\") {\n    return propertyKeyOrFunction;\n  }\n}\n\nfunction createChainableTypeChecker(validator) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n      rest[_key - 6] = arguments[_key];\n    }\n\n    return untracked(function () {\n      componentName = componentName || \"<<anonymous>>\";\n      propFullName = propFullName || propName;\n\n      if (props[propName] == null) {\n        if (isRequired) {\n          var actual = props[propName] === null ? \"null\" : \"undefined\";\n          return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n        }\n\n        return null;\n      } else {\n        // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n        return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));\n      }\n    });\n  }\n\n  var chainedCheckType = checkType.bind(null, false); // Add isRequired to satisfy Requirable\n\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n} // Copied from React.PropTypes\n\n\nfunction isSymbol(propType, propValue) {\n  // Native Symbol.\n  if (propType === \"symbol\") {\n    return true;\n  } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n  if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n    return true;\n  } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n  if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n    return true;\n  }\n\n  return false;\n} // Copied from React.PropTypes\n\n\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n\n  if (Array.isArray(propValue)) {\n    return \"array\";\n  }\n\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return \"object\";\n  }\n\n  if (isSymbol(propType, propValue)) {\n    return \"symbol\";\n  }\n\n  return propType;\n} // This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\n\n\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n\n  if (propType === \"object\") {\n    if (propValue instanceof Date) {\n      return \"date\";\n    } else if (propValue instanceof RegExp) {\n      return \"regexp\";\n    }\n  }\n\n  return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    return untracked(function () {\n      if (allowNativeType) {\n        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n      }\n\n      var mobxChecker;\n\n      switch (mobxType) {\n        case \"Array\":\n          mobxChecker = isObservableArray;\n          break;\n\n        case \"Object\":\n          mobxChecker = isObservableObject;\n          break;\n\n        case \"Map\":\n          mobxChecker = isObservableMap;\n          break;\n\n        default:\n          throw new Error(\"Unexpected mobxType: \" + mobxType);\n      }\n\n      var propValue = props[propName];\n\n      if (!mobxChecker(propValue)) {\n        var preciseType = getPreciseType(propValue);\n        var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n        return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n      }\n\n      return null;\n    });\n  });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n      rest[_key2 - 5] = arguments[_key2];\n    }\n\n    return untracked(function () {\n      if (typeof typeChecker !== \"function\") {\n        return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n      } else {\n        var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n        if (error instanceof Error) return error;\n        var propValue = props[propName];\n\n        for (var i = 0; i < propValue.length; i++) {\n          error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n          if (error instanceof Error) return error;\n        }\n\n        return null;\n      }\n    });\n  });\n}\n\nvar observableArray = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Object\");\nvar PropTypes = {\n  observableArray: observableArray,\n  observableArrayOf: observableArrayOf,\n  observableMap: observableMap,\n  observableObject: observableObject,\n  arrayOrObservableArray: arrayOrObservableArray,\n  arrayOrObservableArrayOf: arrayOrObservableArrayOf,\n  objectOrObservableObject: objectOrObservableObject\n};\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\");\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\");\n\nexport { MobXProviderContext, PropTypes, Provider, disposeOnUnmount, inject, observer };\n//# sourceMappingURL=mobxreact.esm.js.map\n","import React, { Component } from 'react'\n\nconst isServer = typeof window === 'undefined'\n\ntype State = JSX.Element[] | undefined\n\ntype SideEffectProps = {\n  reduceComponentsToState: <T>(\n    components: Array<React.ReactElement<any>>,\n    props: T\n  ) => State\n  handleStateChange?: (state: State) => void\n  headManager: any\n  inAmpMode?: boolean\n}\n\nexport default class extends Component<SideEffectProps> {\n  private _hasHeadManager: boolean\n\n  emitChange = (): void => {\n    if (this._hasHeadManager) {\n      this.props.headManager.updateHead(\n        this.props.reduceComponentsToState(\n          [...this.props.headManager.mountedInstances],\n          this.props\n        )\n      )\n    }\n  }\n\n  constructor(props: any) {\n    super(props)\n    this._hasHeadManager =\n      this.props.headManager && this.props.headManager.mountedInstances\n\n    if (isServer && this._hasHeadManager) {\n      this.props.headManager.mountedInstances.add(this)\n      this.emitChange()\n    }\n  }\n  componentDidMount() {\n    if (this._hasHeadManager) {\n      this.props.headManager.mountedInstances.add(this)\n    }\n    this.emitChange()\n  }\n  componentDidUpdate() {\n    this.emitChange()\n  }\n  componentWillUnmount() {\n    if (this._hasHeadManager) {\n      this.props.headManager.mountedInstances.delete(this)\n    }\n    this.emitChange()\n  }\n\n  render() {\n    return null\n  }\n}\n","import { makeObservable } from \"mobx\";\nimport { useState } from \"react\";\nif (!useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n//# sourceMappingURL=assertEnvironment.js.map","import { configure } from \"mobx\";\nexport function defaultNoopBatch(callback) {\n    callback();\n}\nexport function observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (\"production\" !== process.env.NODE_ENV) {\n            console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n        }\n    }\n    configure({ reactionScheduler: reactionScheduler });\n}\nexport var isObserverBatched = function () {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\"[MobX] Deprecated\");\n    }\n    return true;\n};\n//# sourceMappingURL=observerBatching.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useCallback, useState } from \"react\";\nvar EMPTY_ARRAY = [];\nexport function useForceUpdate() {\n    var _a = __read(useState(0), 2), setTick = _a[1];\n    var update = useCallback(function () {\n        setTick(function (tick) { return tick + 1; });\n    }, EMPTY_ARRAY);\n    return update;\n}\nvar deprecatedMessages = [];\nexport function useDeprecated(msg) {\n    if (!deprecatedMessages.includes(msg)) {\n        deprecatedMessages.push(msg);\n        console.warn(msg);\n    }\n}\n//# sourceMappingURL=utils.js.map","import { getDependencyTree } from \"mobx\";\nexport function printDebugValue(v) {\n    return getDependencyTree(v);\n}\n//# sourceMappingURL=printDebugValue.js.map","var FinalizationRegistryLocal = typeof FinalizationRegistry === \"undefined\" ? undefined : FinalizationRegistry;\nexport { FinalizationRegistryLocal as FinalizationRegistry };\n//# sourceMappingURL=FinalizationRegistryWrapper.js.map","export function createTrackingData(reaction) {\n    var trackingData = {\n        reaction: reaction,\n        mounted: false,\n        changedBeforeMount: false,\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n//# sourceMappingURL=reactionCleanupTrackingCommon.js.map","var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { CLEANUP_TIMER_LOOP_MILLIS, createTrackingData } from \"./reactionCleanupTrackingCommon\";\n/**\n * timers, gc-style, uncommitted reaction cleanup\n */\nexport function createTimerBasedReactionCleanupTracking() {\n    /**\n     * Reactions created by components that have yet to be fully mounted.\n     */\n    var uncommittedReactionRefs = new Set();\n    /**\n     * Latest 'uncommitted reactions' cleanup timer handle.\n     */\n    var reactionCleanupHandle;\n    /* istanbul ignore next */\n    /**\n     * Only to be used by test functions; do not export outside of mobx-react-lite\n     */\n    function forceCleanupTimerToRunNowForTests() {\n        // This allows us to control the execution of the cleanup timer\n        // to force it to run at awkward times in unit tests.\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            cleanUncommittedReactions();\n        }\n    }\n    /* istanbul ignore next */\n    function resetCleanupScheduleForTests() {\n        var e_1, _a;\n        if (uncommittedReactionRefs.size > 0) {\n            try {\n                for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {\n                    var ref = uncommittedReactionRefs_1_1.value;\n                    var tracking = ref.current;\n                    if (tracking) {\n                        tracking.reaction.dispose();\n                        ref.current = null;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a = uncommittedReactionRefs_1.return)) _a.call(uncommittedReactionRefs_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            uncommittedReactionRefs.clear();\n        }\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            reactionCleanupHandle = undefined;\n        }\n    }\n    function ensureCleanupTimerRunning() {\n        if (reactionCleanupHandle === undefined) {\n            reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n        }\n    }\n    function scheduleCleanupOfReactionIfLeaked(ref) {\n        uncommittedReactionRefs.add(ref);\n        ensureCleanupTimerRunning();\n    }\n    function recordReactionAsCommitted(reactionRef) {\n        uncommittedReactionRefs.delete(reactionRef);\n    }\n    /**\n     * Run by the cleanup timer to dispose any outstanding reactions\n     */\n    function cleanUncommittedReactions() {\n        reactionCleanupHandle = undefined;\n        // Loop through all the candidate leaked reactions; those older\n        // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n        var now = Date.now();\n        uncommittedReactionRefs.forEach(function (ref) {\n            var tracking = ref.current;\n            if (tracking) {\n                if (now >= tracking.cleanAt) {\n                    // It's time to tidy up this leaked reaction.\n                    tracking.reaction.dispose();\n                    ref.current = null;\n                    uncommittedReactionRefs.delete(ref);\n                }\n            }\n        });\n        if (uncommittedReactionRefs.size > 0) {\n            // We've just finished a round of cleanups but there are still\n            // some leak candidates outstanding.\n            ensureCleanupTimerRunning();\n        }\n    }\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, \n        /**\n         * On timer based implementation we don't really need this object,\n         * but we keep the same api\n         */\n        objectRetainedByReact) {\n            reactionTrackingRef.current = createTrackingData(reaction);\n            scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: recordReactionAsCommitted,\n        forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests,\n        resetCleanupScheduleForTests: resetCleanupScheduleForTests\n    };\n}\n//# sourceMappingURL=createTimerBasedReactionCleanupTracking.js.map","import { FinalizationRegistry as FinalizationRegistryMaybeUndefined } from \"./FinalizationRegistryWrapper\";\nimport { createReactionCleanupTrackingUsingFinalizationRegister } from \"./createReactionCleanupTrackingUsingFinalizationRegister\";\nimport { createTimerBasedReactionCleanupTracking } from \"./createTimerBasedReactionCleanupTracking\";\nvar _a = FinalizationRegistryMaybeUndefined\n    ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryMaybeUndefined)\n    : createTimerBasedReactionCleanupTracking(), addReactionToTrack = _a.addReactionToTrack, recordReactionAsCommitted = _a.recordReactionAsCommitted, resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests, forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;\nexport { addReactionToTrack, recordReactionAsCommitted, resetCleanupScheduleForTests, forceCleanupTimerToRunNowForTests };\n//# sourceMappingURL=reactionCleanupTracking.js.map","import { createTrackingData } from \"./reactionCleanupTrackingCommon\";\n/**\n * FinalizationRegistry-based uncommitted reaction cleanup\n */\nexport function createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry) {\n    var cleanupTokenToReactionTrackingMap = new Map();\n    var globalCleanupTokensCounter = 1;\n    var registry = new FinalizationRegistry(function cleanupFunction(token) {\n        var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);\n        if (trackedReaction) {\n            trackedReaction.reaction.dispose();\n            cleanupTokenToReactionTrackingMap.delete(token);\n        }\n    });\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, objectRetainedByReact) {\n            var token = globalCleanupTokensCounter++;\n            registry.register(objectRetainedByReact, token, reactionTrackingRef);\n            reactionTrackingRef.current = createTrackingData(reaction);\n            reactionTrackingRef.current.finalizationRegistryCleanupToken = token;\n            cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: function (reactionRef) {\n            registry.unregister(reactionRef);\n            if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {\n                cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);\n            }\n        },\n        forceCleanupTimerToRunNowForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        },\n        resetCleanupScheduleForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        }\n    };\n}\n//# sourceMappingURL=createReactionCleanupTrackingUsingFinalizationRegister.js.map","var globalIsUsingStaticRendering = false;\nexport function enableStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexport function isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n//# sourceMappingURL=staticRendering.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useForceUpdate } from \"./utils/utils\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(React.useState(new ObjectToBeRetainedByReact()), 1), objectRetainedByReact = _a[0];\n    var forceUpdate = useForceUpdate();\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData_1.changedBeforeMount = true;\n            }\n        });\n        var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent, options) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var realOptions = __assign({ forwardRef: false }, options);\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    var wrappedComponent = function (props, ref) {\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\n    };\n    wrappedComponent.displayName = baseComponentName;\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    var memoComponent;\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent));\n    }\n    else {\n        memoComponent = memo(wrappedComponent);\n    }\n    copyStaticProperties(baseComponent, memoComponent);\n    memoComponent.displayName = baseComponentName;\n    return memoComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n//# sourceMappingURL=observer.js.map","import { useObserver } from \"./useObserver\";\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return useObserver(component);\n}\nif (\"production\" !== process.env.NODE_ENV) {\n    ObserverComponent.propTypes = {\n        children: ObserverPropsCheck,\n        render: ObserverPropsCheck\n    };\n}\nObserverComponent.displayName = \"Observer\";\nexport { ObserverComponent as Observer };\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n//# sourceMappingURL=ObserverComponent.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useDeprecated } from \"./utils/utils\";\nimport { observable, runInAction } from \"mobx\";\nimport { useState } from \"react\";\nexport function useAsObservableSource(current) {\n    if (\"production\" !== process.env.NODE_ENV)\n        useDeprecated(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n    var _a = __read(useState(function () { return observable(current, {}, { deep: false }); }), 1), res = _a[0];\n    runInAction(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\n//# sourceMappingURL=useAsObservableSource.js.map","import \"./utils/assertEnvironment\";\nimport { unstable_batchedUpdates as batch } from \"./utils/reactBatchedUpdates\";\nimport { observerBatching } from \"./utils/observerBatching\";\nimport { useDeprecated } from \"./utils/utils\";\nimport { useObserver as useObserverOriginal } from \"./useObserver\";\nimport { enableStaticRendering } from \"./staticRendering\";\nobserverBatching(batch);\nexport { isUsingStaticRendering, enableStaticRendering } from \"./staticRendering\";\nexport { observer } from \"./observer\";\nexport { Observer } from \"./ObserverComponent\";\nexport { useLocalObservable } from \"./useLocalObservable\";\nexport { useLocalStore } from \"./useLocalStore\";\nexport { useAsObservableSource } from \"./useAsObservableSource\";\nexport { resetCleanupScheduleForTests as clearTimers } from \"./utils/reactionCleanupTracking\";\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (\"production\" !== process.env.NODE_ENV) {\n        useDeprecated(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n    }\n    return useObserverOriginal(fn, baseComponentName);\n}\nexport { isObserverBatched, observerBatching } from \"./utils/observerBatching\";\nexport function useStaticRendering(enable) {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n    }\n    enableStaticRendering(enable);\n}\n//# sourceMappingURL=index.js.map","module.exports = require('./dist/next-server/lib/head')\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","import React from 'react'\n\nexport const AmpStateContext: React.Context<any> = React.createContext({})\n\nif (process.env.NODE_ENV !== 'production') {\n  AmpStateContext.displayName = 'AmpStateContext'\n}\n","module.exports =\n/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 149:\n/***/ (function(module) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nccwpck_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat */\n/******/ \t\n/******/ \t__nccwpck_require__.ab = __dirname + \"/\";/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nccwpck_require__(149);\n/******/ })()\n;"],"sourceRoot":""}